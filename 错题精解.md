# 错题精解

> 牛客网基础题总结。

---

## 目录

---

| Chapter 1 | Chapter 2 | Chapter 3| Chapter 4 | Chapter 5 | Chapter 6 | Chapter 7 |
| --------- | --------- | --------- | --------- | --------- | -------- | --------- | 
|[编程语言(C++)](#prog)|[数据结构与算法](#ds)|[计算机网络](#net)|[操作系统](#os)|[Linux工具](#inx)|[数据库](#db)|[设计模式](#des)| 

---

## 内容

---

### <span id = "prog">编程语言(C++)</span>

#### [Q 1](http://www.cnblogs.com/skynet/p/3343726.html) : 

    题目：
        以下代码：
        class ClassA{
        public:
            virtual ~ ClassA(){};
            virtual void FunctionA(){};
        };
        class ClassB{
        public:
            virtual void FunctionB(){};
        };
        class ClassC : public ClassA, public ClassB{
            public:
        };
        ClassC Object; 
        ClassA* pA=&Object; 
        ClassB* pB=&Object;
        ClassC* pC=&Object; 
        关于pA,pB,pC的取值,下面的描述中正确的是:

    答案:
        pA和pB不相同

    解答:
        考察多继承切有虚函数情况下C++存储对象模型。
        1. 多继承按继承顺序组织对象模型，有虚函数时低地址包含指向虚函数表的指针。 
        2. 对象Object的存储模型：类A虚函数表指针(ptrA) | 类A数据 | 类B虚函数表指针(ptrB) | 类B数据 | 类C数据。
        3. 子类的虚函数被放到了第一个基类的虚函数表最后（ptrA指向的虚函数表结构：类A虚函数 | 类C虚函数）。
        4. 有虚函数的继承，对象地址为指向虚函数表的指针的地址，即pC = &Object = &ptrA。
        6. pC = pA = &ptrA = &Object，(pC = pA) < pB。

#### [Q 2](http://www.cnblogs.com/qlwy/archive/2011/08/25/2153584.html) :

    题目：
        下列程序的输出结果：
        #include <iostream>
        using namespace std;
        class A{
        public:
            void print(){
                cout << "A:print()";
            }
        };
        class B: private A{
        public:
            void print(){
              cout << "B:print()";
            }
        };
        class C: public B{
        public:
           void print(){
                A:: print();
            }
        };
        int main(){
            C b;
            b.print();
        }

    答案:
        编译出错

    解答:
        考察C++继承问题。
        1. 类B私有继承类A。
        2. 私有继承：类A的公有成员和保护成员都作为类B的私有成员，并且不能被类B的子类（如类C）所访问。

#### [Q 3](http://www.cnblogs.com/motadou/archive/2009/01/17/1558438.html) :

    题目：
        下面两个结构体：
        struct One{
            double d;
            char c;
            int i;
        }
        struct Two{
            char c;
            double d;
            int i;
        }
        在#pragma pack(4)和#pragma pack(8)的情况下，结构体的大小分别是：
   
    答案: 
        16 16,16 24

    解答:
        考察结构体对齐。
        1. 4字节对齐：Struct One[8 + (1 + 3) + 4], struct Two[(1 + 3) + 8 + 4]。
        2. 8字节对齐：Struct One[8 + (1 + 4 + 3)], struct Two[(1 + 7) + 8 + (4 + 4)]。
        3. 一句话总结：按序存储，装得下尽量装，装不下换一行。

#### [Q 4](http://blog.csdn.net/dgyanyong/article/details/21268469) : 

    题目：
        下列代码的输出为：
        #include "iostream"  
        #include "vector"  
        using namespace std;    
        int main(void)  
        {  
            vector<int>array;  
            array.push_back(100);  
            array.push_back(300);  
            array.push_back(300);  
            array.push_back(500);  
            vector<int>::iterator itor;  
            for(itor=array.begin();itor!=array.end();itor++){  
                if(*itor==300){  
                    itor = array.erase(itor);  
                }  
            }  
            for(itor=array.begin();itor!=array.end();itor++){  
                cout<<*itor<<" ";  
            }  
            return 0;  
        }  
   
    答案: 
        100  300  500

    解答:
        考察STL中erase和迭代器问题。
        1. erase返回值是一个迭代器，指向删除元素下一个元素。
        2. 删除第一个300时返回指向下一个300的迭代器，在循环体又被再加了一次，跳过了第二个300。

#### Q 5 : 

    题目：
  
   
    答案: 
 

    解答:


---

### <span id = "ds">数据结构与算法</span>

> 待补充

---

### <span id = "net">计算机网络</span>

> 待补充

---

### <span id = "os">操作系统</span>

> 待补充

---

### <span id = "inx">Linux工具</span>

> 待补充

---

### <span id = "db">数据库</span>

> 待补充

---

### <span id = "des">设计模式</span>

> 待补充