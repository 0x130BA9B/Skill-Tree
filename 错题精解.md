# 错题精解

> 牛客网基础题总结。

---

# 目录

| Chapter 1 | Chapter 2 |
| :---------: | :---------: |
|[编程语言(C++)](#prog)|[其他](#other)|

---

# 内容

## <span id = "prog">编程语言(C++)</span>

#### [Q 1](http://www.cnblogs.com/skynet/p/3343726.html) : 

    题目：
        以下代码：
        class ClassA{
        public:
            virtual ~ClassA(){};
            virtual void FunctionA(){};
        };
        class ClassB{
        public:
            virtual void FunctionB(){};
        };
        class ClassC:public ClassA, public ClassB{
            public:
        };
        ClassC Object;
        ClassA* pA = &Object;
        ClassB* pB = &Object;
        ClassC* pC = &Object;
        关于pA,pB,pC的取值,下面的描述中正确的是:

    答案:
        pA和pB不相同

    解答:
        考察多继承且有虚函数情况下C++存储对象模型。
        1. 多继承按继承顺序组织对象模型，有虚函数时低地址包含指向虚函数表的指针。
        2. 对象Object的存储模型：类A虚函数表指针(ptrA) | 类A数据 | 类B虚函数表指针(ptrB) | 类B数据 | 类C数据。
        3. 子类的虚函数被放到了第一个基类的虚函数表最后（ptrA指向的虚函数表结构：类A虚函数 | 类C虚函数）。
        4. 有虚函数的继承，对象地址为指向虚函数表的指针的地址，即pC = &Object = &ptrA。
        6. pC = pA = &ptrA = &Object，(pC = pA) < pB。

#### [Q 2](http://www.cnblogs.com/qlwy/archive/2011/08/25/2153584.html) :

    题目：
        下列程序的输出结果：
        #include <iostream>
        using namespace std;
        class A{
        public:
            void print(){
                cout << "A:print()";
            }
        };
        class B:private A{
        public:
            void print(){
              cout << "B:print()";
            }
        };
        class C:public B{
        public:
           void print(){
                A::print();
            }
        };
        int main(){
            C b;
            b.print();
        }

    答案:
        编译出错

    解答:
        考察C++继承问题。
        1. 类B私有继承类A。
        2. 私有继承：类A的公有成员和保护成员都作为类B的私有成员，并且不能被类B的子类（如类C）所访问。

#### [Q 3](http://www.cnblogs.com/motadou/archive/2009/01/17/1558438.html) :

    题目：
        下面两个结构体：
        struct One{
            double d;
            char c;
            int i;
        }
        struct Two{
            char c;
            double d;
            int i;
        }
        在#pragma pack(4)和#pragma pack(8)的情况下，结构体的大小分别是：

    答案:
        16，16
        16，24

    解答:
        考察结构体对齐。
        1. 4字节对齐：Struct One[8 + (1 + 3(pading)) + 4], struct Two[(1 + 3(pading)) + 8 + 4]。
        2. 8字节对齐：Struct One[8 + (1 + 3(pading) + 4)], struct Two[(1 + 7(pading)) + 8 + (4 + 4(pading))]。
        3. 一句话总结：按序存储，装得下尽量装，装不下换一行。

#### [Q 4](http://blog.csdn.net/dgyanyong/article/details/21268469) :

    题目：
        下列代码的输出为：
        #include "iostream"
        #include "vector"
        using namespace std;
        int main(void)
        {
            vector<int>array;
            array.push_back(100);
            array.push_back(300);
            array.push_back(300);
            array.push_back(500);
            vector<int>::iterator itor;
            for(itor = array.begin(); itor != array.end(); itor++){
                if(*itor == 300){
                    itor = array.erase(itor);
                }
            }
            for(itor = array.begin(); itor != array.end(); itor++){
                cout << *itor << " ";
            }
            return 0;
        }

    答案:
        100
        300
        500

    解答:
        考察STL中erase和迭代器问题。
        1. erase返回值是一个迭代器，指向删除元素下一个元素。
        2. 删除第一个300时返回指向下一个300的迭代器，在循环体又被再加了一次，跳过了第二个300。

#### Q 5 :

    题目：
        下面程序的输出是什么？
        int main(void)
        {
            int a[5] = {1, 2, 3, 4, 5};
            int *ptr = (int *)(&a + 1);
            printf("%d,%d", *(a + 1), *(ptr - 1));
            return 0;
        }

    答案:
        2
        5

    解答:
        1. a表示数组首元素的地址，对a的所有操作均是以一个元素为单位的。
        2. &a表示整个数组的地址，对&a的所有操作均是以一个数组为单位的。
        3. ptr类型为int *，所有对ptr的所有操作均是以int大小为单位进行的。
        4. (int *)(&a + 1)表示指向a数组最后一个字节的int类型指针，*(ptr - 1)表示向前移动一个int类型的数据的位置。
        5. 所有指针类型操作先看右侧是以什么为单位，之后再转换为左侧定义的单位。

#### Q 6 :

    题目：
        32位机上根据下面的代码，问哪些说法是正确的？
        signed char a = 0xe0;
        unsigned int b = a;
        unsigned char c = a;

    答案:
        b的十六进制表示是：0xffffffe0

    解答:
        考察有符号数和无符号数之间的转换。
        1. a : 1110 0000。
        2. 扩展问题：
            长 -> 短：低位对齐，按位复制。
            短 -> 长：符号位扩展。
        3. 精度提升：
            两个变量运算，表示范围小的变量精度达的变量提升（signed -> unsigned）。

#### Q 7 :

    题目：
        下列代码的输出为：
        int* pint = 0;
        pint += 6;
        cout << pint << endl;

    答案:
        24

    解答:
        考察指针运算。
        1. 变量pint为指向int类型的指针，这里“+1”表示地址加4（pint值加4）。
        2. 变量pint初值为0，pint + 6后pint的值变为24。

#### Q 8 :

    题目：
        如果两段内存重叠，用memcpy函数可能会导致行为未定义。而memmove函数能够避免这种问题，下面是一种实现方式，请补充代码。
        #include <iostream>
        using namespace std;
        void* memmove(void* str1, const void* str2, size_t n)
        {
            char* pStr1 = (char*) str1;
            const char* pStr2 = (const char*)str2;
            if( ){
                for(size_t i = 0;i != n; ++i){
                    *(pStr1++) = *(pStr2++);
                }
            }
            else{
                pStr1 += n - 1;
                pStr2 += n - 1;
                for(size_t i = 0; i != n; ++i){
                    *(pStr1--) = *(pStr2--);
                }
            }
            return ( );
        }

    答案:
        pStr1 < pStr2
        str1

    解答:
        1. 逐字符自动不存在内存覆盖问题。

#### Q 9 :

    题目：
        设x、y、t均为int型变量，则执行语句：t = 3; x = y = 2; t = x++ || ++y; 后，变量t和y的值分别为：

    答案:
        t = 1
        y = 2

    解答:
        考察逻辑短路和运算符优先级。
        1. =的优先级最低，t = (x++ || ++y) = 1。
        2. x++和++y为或关系，因为x++的值非0，所以++y不执行，y不变。

#### Q 10 :

    题目：
        指出下面程序哪里可能有问题？
        class CBuffer
        {
            char * m_pBuffer;
            int m_size;
        public:
            CBuffer(){
                m_pBuffer = NULL;
            }
            ~CBuffer(){
                Free();
            }
            void Allocte(int size) (1) {
                m_size = size;
                m_pBuffer = new char[size];
            }
        private:
            void Free(){
                if(m_pBuffer! = NULL) (2){
                    delete[] m_pBuffer;
                    m_pBuffer = NULL;
                }
            }
        public:
            void SaveString(const char* pText) const (3){
                strcpy(m_pBuffer, pText); (4)
            }
            char* GetBuffer() const{
                return m_pBuffer;
            }
        };
        void main (int argc, char* argv[])
        {
            CBuffer buffer1;
            buffer1.SaveString("Microsoft");
            printf(buffer1.GetBuffer());
        }

    答案:
        1
        3
        4

    解答:
        考察动态分配空间等周边细节处理。
        1. 分配内存时, 未检测m_pBuffer是否为空, 容易造成内存泄露。
        2. 常成员函数不应该对数据成员做出修改, 虽然可以修改指针数据成员指向的数据, 但原则上不应该这么做。
        3. 字符串拷贝时, 未检测是否有足够空间, 可能造成程序崩溃。

#### [Q 11](http://blog.csdn.net/candyliuxj/article/details/6307814) :

    题目：
        某32位系统下, C++程序，请计算sizeof 的值：
        char str[] = "http://www.xxxxx.com";
        char *p = str;
        int n = 10;
        sizeof(str) = (1);
        sizeof(p) = (2;
        sizeof(n) = (3);
        void Foo(char str[100]){
            sizeof(str) = (4);
        }
        void *p = malloc(100);
        sizeof(p) = (5);

    答案:
        21
        4
        4
        4
        4

    解答:
        考察sizeof返回值。
        1. 具体类型，返回该类型所占的空间大小。
        2. 对象，返回对象的实际占用空间大小。
        3. 数组，返回编译时分配的数组空间大小（数组名 ≠ 指针）。作为参数时数组退化为指针。
        4. 指针，返回存储该指针所用的空间大小。
        5. 函数，返回函数的返回类型所占的空间大小。函数的返回类型不能是void。
        6. 上题中(2)(4)(5)均为指针。

#### [Q 12](http://blog.csdn.net/heyabo/article/details/8745942) :

    题目：
        在C++中，
        const int i = 0;
        int *j = (int *) &i;
        *j = 1;
        printf("%d, %d", i, *j);
        输出是多少？

    答案:
        0
        1

    解答:
        考察C++常量折叠。
        1. const变量放在编译器的符号表中，计算时编译器直接从表中取值，省去了访问内存的时间，从而达到了优化。
        2. 结论，const变量通过取地址方式可以修改该地址存储的数据值，但不能修改常量的值。

#### Q 13 :

    题目：
        下列代码的输出为：
        class parent{
        public:
            virtual void output();
        };
        void parent::output(){
            printf("parent!");
        }
        class son : public parent{
        public:
            virtual void output();
        };
        void son::output(){
            printf("son!");
        }
        son s;
        memset(&s, 0, sizeof(s));
        parent& p = s;
        p.output();

    答案:
        没有输出结果，程序运行出错。

    解答:
        考察memset和虚函数指针。
        1. 虚函数表地址被清空。

#### Q 14 :

    题目：
        有哪几种情况只能用intialization list而不能用assignment？

    答案:
        当类中含有const成员变量；基类无默认构造函数时，有参的构造函数都需要初始化表；当类中含有reference成员变量。

    解答:
        1. 见答案。

#### [Q 15](http://blog.csdn.net/yby4769250/article/details/7294696) :

    题目：
        对以下数据结构中data的处理方式描述正确的是：
        struct Node{
            int size;
            char data[0];
        };

    答案:
        编译器会认为这就是一个长度为0的数组,而且会支持对于数组data的越界访问。

    解答:
        考察柔性数组。
        1. 柔性数组，作为占位符放在结构体末尾，使得结构体的大小动态可变，在声明结构体变量的时候可根据需要动态分配内存。
        2. 长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量， 数组名这个符号本身代表了一个不可修改的地址常量。
        3. 常用于网络通信中构造不定长数据包，不会浪费空间浪费网络流量。

#### Q 16 :

    题目：
        给定3个int类型的正整数x，y，z，对如下4组表达式判断正确的选项：
        int a1 = x + y - z; int a2 = x - z + y;
        int b1 = x * y / z; int b2 = x / z * y;
        int c1 = x << y >> z; int c2 = x >> z << y ;
        int d1 = x & y | z; int d2 = x | z & y;

    答案:
        a1一定等于a2

    解答:
        考察对变量运算原理的了解。
        1. 加减操作虽然可能出现溢出，但相同操作数的不同顺序只是中间结果不同，最终结果相同。
        2. int类型做除法可能会造成截断，比如3/2 = 1。
        3. 移位运算可能会丢弃超出的位数。有符号数二进制数1111 1111，先左移2位再右移三位为1111 1111，反之1111 1100。

#### Q 17 : 

    题目：
        若有以下定义和语句：
        char s1[] = "12345", *s2 = "1234";
        printf("%d\n", strlen(strcpy(s1, s2)));
        则输出结果是：

    答案:
        4

    解答:
        考察strcpy和strlen。
        1. 首先strlen得到的是'\0'之前的字符长度。
        2. strcpy将s2指向的字符串'1234\0'全部拷贝到s1指向位置并覆盖其'12345'部分。

#### Q 18 :

    题目：
        以下函数用法正确的个数是：
        void test1(){
            unsigned char array[MAX_CHAR + 1], i;
            for(i = 0;i <= MAX_CHAR; i++){
                array[i] = i;
            }
        }
        char*test2(){
            char p[] = "hello world";
            return p;
        }
        char *p = test2();
        void test3(){
            char str[10];
            str++;
            *str = '0';
        }

    答案:
        0

    解答:
        考察数组名和指针区别。
        1. i的范围有可能超过unsigned char范围。
        2. 这里char p[] = "hello world"是数组，该数组是临时变量，函数结束后不能继续使用。
        3. 如果为char *p = "hello world"，这里p是指针并指向常量区字串，虽然p会被销毁，但字符串仍然在，就不会出问题。
        4. 这里str是数组名，数组名是常量，不可以自增，正确的操作是char *p = str; p++; *p = '0'。

#### Q 19 :

    题目：
        假设在一个32位little endian的机器上运行下面的程序，结果是多少？
        #include <stdio.h>
        int main(){
            long long a = 1, b = 2, c = 3;
            printf("%d %d %d\n", a, b, c);
            return 0;
        }

    答案:
        1
        0
        2

    解答:
        考察小端法及printf输出控制符。
        1. long long占8字节。
        2. 小端表示，低字节在低位，最低4字节为1，接下来四字节为高位部分的0，再接下来4字节为第二个数低位的2。

#### Q 20 :

    题目：
        请选择下列程序的运行结果:
        #include<iostream>
        using namespace std;
        class B0{
        public:
            virtual void display(){
                cout << "B0::display0" << endl;
            }
        };
        class B1:public B0{
        public:
            void display(){
                cout << "B1::display0" << endl;
            }
        };
        class D1: public B1{
        public:
            void display(){
                cout << "D1::display0" << endl;
            }
        };
        void fun(B0 ptr){
            ptr.display();
        }
        int main(){
            B0 b0;
            B1 b1;
            D1 d1;
            fun(b0);
            fun(b1);
            fun(d1);
        }

    答案:
        B0::display0
        B0::display0
        B0::display0
    解答:
        1. 这里传递的是对象本身而非指针，对象被直接转为基类对象，调用基类的函数。
        2. 如果要实现虚函数动态绑定需要将B0 ptr改为B0* ptr，ptr->display()。

#### Q 21 :

    题目：
        i的初始值为0，i++在两个线程里面分别执行100次，能得到最大值是()，最小值是()。

    答案:
        200
        2

    解答:
        考察多线程操作同一未上锁变量。
        1. 每次都准确加1，结果为最大，200。
        2. 结果为2时步骤：
            a取内存0到寄存器，b取内存0到寄存器；
            a执行99次并写入内存，内存值为99；
            b执行1次并写入内存，内存值被覆盖为1；
            a取内存1到寄存器，b取内存1到寄存器；
            b执行99次并写入内存，内存值为100；
            a执行1次，写入内存，覆盖之前的100，值为2。
        3. 每次计算过程必须是先从内存取数然后计算，之后再重新写入内存。但对各个线程而言，取数和计算中间可以被另一个线程打断。

#### Q 22 :

    题目：
        char fun(char x, char y){
            if(x)
                return(y);
        }
        int main(){
            int a = '0', b = '1', c = '2';
            printf("%c\n", fun(fun(a, b), fun(b, c)));
        }

    答案:
        2

    解答:
        1. 均为字符，非布尔值的0，所以每次返回后者。

#### Q 23 :

    题目：
        当一个类A中没有声明任何成员变量与成员函数,这时sizeof(A)的值是多少？

    答案:
        1

    解答:
        1. 一个空类对象的大小是1byte。这是被编译器安插进去的一个字节，这样就使得这个空类的两个实例得以在内存中配置独一无二的地址。

#### Q 24 :

    题目：
        有以下程序：
        #include<stdio.h>
        #include<stdlib.h>
        void fun(int *pl, int *p2, int *s){
            s = (int*)calloc(1, sizeof(int));
            *s = *pl + *p2;
            free(s);
        }
        int main(){
            int a[2] = {1, 2}, b[2] = {40, 50}, *q = a;
            fun(a, b, q);
            printf("%d\n", *q);
        }

    答案:
        1

    解答:
        考察形参不改变变量值问题。
        1. p是指针变量，但是是值传递，其值(指向数组a首元素的地址)并没有改变。

#### [Q 25](http://www.cnblogs.com/klcf0220/p/6889122.htmls) :

    题目：
        在32位操作系统gcc编译器环境下，下面程序的运行结果为：
        #include <iostream>
        using namespace std;
        class A{
        public:
            int b;
            char c;
            virtual void print(){
                cout << "this is father’s fuction! " << endl;
            }
        };
        class B: A{
        public:
            virtual void print(){
                cout << "this is children’s fuction! " << endl;
            }
        };
        int main(int argc, char * argv[]){
            cout << sizeof(A) << " " << sizeof(B) << endl;
            return 0;
        }

    答案:
        12
        12

    解答:
        考察结构体对齐及虚继承和虚函数继承的区别。
        1. A的大小包括本身的虚函数指针及定义的变量。
        2. B的大小包括本身的虚函数指针和继承自A的变量b和c。
        3. 如果是虚继承，则B的大小会增加4字节，增加的内容为指向虚继承的指针。

#### Q 26 :

    题目：
        有如下语句序列：
        char str[10]；
        cin >> str；
        当从键盘输入"I love this game"时，str中的字符串是:

    答案:
        I
    解答:
        1. cin遇空格，结束输入。

#### Q 27 :

    题目：
        阅读下面代码，程序会打印出来的值是：
        #include <stdio.h>
        void f(char** p){
            *p += 2;
        }
        int main(){
            char *a[] = {"123", "abc", "456"}, **p;
            p = a;
            f(p);
            printf("%s\r\n", *p);
        }

    答案:
        3

    解答:
        1. p的类型为char **，(*P)的类型为char *。
        2. p原本指向字符串"123"。
        3. *p是char *类型的，*p + 2表示指向第一个字符串第三个字符。
        4. p是char **类型的，p + 2表示只想第三个字符串，*(p + 2) = "456"。
        5. p的值是*p的地址，虽然p是形参本身值未变，但*p的值在调用函数中被改变。

#### [Q 28](http://www.cnblogs.com/skynet/archive/2010/09/05/1818636.html) :

    题目：
        下列对函数double add(int a, int b)进行重载，正确的是：

    答案:
        int add(int a, int b, int c)
        int add(double a, double b)
        double add(double a, double b)

    解答:
        考察重载概念。
        1. 在使用重载时只能通过相同的方法名，不同的参数形式实现。
        2. 不同参数形式包括：
            参数类型不同（至少有一个）
            参数个数不同
            *如果同时在类中，对于函数名相同的const函数和非const函数能够构成重载
        3. 编译器区分重载函数是通过“返回类型 + 函数名 + 参数列表”重新改写函数名还区分重载函数的，但返回值类型在C++中并不作为重载标记。

#### Q 29 :

    题目：
        在linux gcc下，关于以下代码，正确的是：
        std::string& test_str(){
            std::string str = "test";
            return str;
        }
        int main(){
            std::string& str_ref = test_str();
            std::cout << str_ref << std::endl;
            return 0;
        }

    答案:
        编译警告
        返回局部变量的引用,运行时出现未知错误
        把代码里的&都去掉之后,程序可以正常运行

    解答:
        考察调用函数返回值和变量生命周期问题。
        1. 返回值为局部变量时可以正确运行。
        2. 返回值为指针时，看指针指向的变量实体定义的位置，如果是定义在栈上的变量则会出错，指向静态区则不会有问题。
        3. 引用返回的是局部变量本身，而不是复制一份再返回，所以结果难以预料。
        4. 如果去掉&，string类会调用复制构造函数，形同局部变量返回，可以正常运行。

#### Q 30 :

    题目：
        下面有关继承、多态、组合的描述，说法错误的是：

    答案:
        继承可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展
        覆盖是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同

    解答:
        考察继承、多态概念。
        1. 父类只有非private的部分才能被子类继承访问。
        2. 重载（overload）：函数名相同 、函数参数不同、 必须位于同一个域（类）中。
        3. 覆盖（override）：函数名相同 、函数参数相同、 分别位于派生类和基类中（虚函数）。

